import ctypes
import struct
import argparse
from ctypes import windll, wintypes

# Constants for device IOCTL
DEVICE_NAME = r"\\.\CCDRV1"
GENERIC_READ = 0x80000000
GENERIC_WRITE = 0x40000000
OPEN_EXISTING = 3

# IOCTL codes for device operations
IOCTL_CODE_HALTEXECUTION = 0x9C402090  # Halt execution IOCTL
IOCTL_CODE_MMIO_IOCTL = 0x9C406104     # MMIO testing IOCTL

# Constants for MSR read/write
MEM_RESERVE = 0x2000
MEM_COMMIT = 0x1000
PAGE_EXECUTE_READWRITE = 0x40
INVALID_HANDLE_VALUE = -1

IOCTL_CODE_READ_MSR = 0x9C402084      # Read MSR IOCTL
IOCTL_CODE_WRITE_MSR = 0x9C402088     # Write MSR IOCTL

# List of MSR indices and their expected format
MSR_LIST = [
    ('IA32_EFER', 0xC0000080, "{:016X}"),
    ('IA32_STAR', 0xC0000081, "{:016X}"),
    ('IA32_LSTAR_MSR', 0xC0000082, "{:016X}"),
    ('IA32_CSTAR_MSR', 0xC0000083, "{:016X}"),
    ('IA32_MSR_FMASK', 0xC0000084, "{:04X}"),
    ('IA32_MSR_GS_BASE', 0xC0000101, "{:016X}"),
    ('IA32_MSR_KERNEL_GS_BASE', 0xC0000102, "{:016X}")
]

# Define the SECURITY_ATTRIBUTES structure
class SECURITY_ATTRIBUTES(ctypes.Structure):
    _fields_ = [
        ('nLength', wintypes.DWORD),
        ('lpSecurityDescriptor', wintypes.LPVOID),
        ('bInheritHandle', wintypes.BOOL),
    ]

class PHYSICAL_ADDRESS(ctypes.Structure):      
    _fields_ = [("LowPart", ctypes.c_ulong),      
                ("HighPart", ctypes.c_long)]    

# Windows API function declarations
kernel32 = ctypes.WinDLL('kernel32', use_last_error=True)

# Function to open the device handle
def open_device_handle(device_name, access_mode):
    handle = kernel32.CreateFileW(
        device_name, 
        access_mode, 
        0, 
        None, 
        OPEN_EXISTING, 
        0, 
        None
    )
    if handle == INVALID_HANDLE_VALUE:
        raise RuntimeError(f"Failed to open device {device_name}. Error code: {kernel32.GetLastError()}")
    return handle

# Function to execute _halt IOCTL
def execute_halt_execution():
    try:
        handle = open_device_handle(DEVICE_NAME, GENERIC_READ | GENERIC_WRITE)
        print(f"Successfully opened device: {DEVICE_NAME}")

        in_buffer = ctypes.create_string_buffer(0)
        out_buffer = ctypes.create_string_buffer(64)
        bytes_returned = ctypes.c_ulong(0)

        status = kernel32.DeviceIoControl(
            handle, 
            IOCTL_CODE_HALTEXECUTION, 
            in_buffer, 
            ctypes.sizeof(in_buffer), 
            out_buffer, 
            len(out_buffer), 
            ctypes.byref(bytes_returned), 
            None
        )

        if status != 0:
            print("_halt IOCTL executed successfully.")
        else:
            print(f"_halt IOCTL execution failed. Error: {kernel32.GetLastError()}")

    finally:
        kernel32.CloseHandle(handle)

# Function to execute MMIO IOCTL
def execute_mmio_ioctl():
    try:
        handle = open_device_handle(DEVICE_NAME, GENERIC_READ | GENERIC_WRITE)
        print(f"Successfully opened device: {DEVICE_NAME}")

        in_buffer = (PHYSICAL_ADDRESS * 2)()      
        in_buffer[1].HighPart = 2       
        in_buffer[1].LowPart = 2   
        out_buffer = ctypes.create_string_buffer(64)
        bytes_returned = ctypes.c_ulong(0)

        status = kernel32.DeviceIoControl(
            handle, 
            IOCTL_CODE_MMIO_IOCTL, 
            in_buffer, 
            ctypes.sizeof(in_buffer), 
            out_buffer, 
            len(out_buffer), 
            ctypes.byref(bytes_returned), 
            None
        )

        if status != 0:
            print("MMIO IOCTL executed successfully.")
        else:
            print(f"MMIO IOCTL execution failed. Error: {kernel32.GetLastError()}")

    finally:
        kernel32.CloseHandle(handle)

# Function to read MSR
def read_msr(msr_index):
    try:
        handle = open_device_handle(DEVICE_NAME, GENERIC_READ)

        lpInBuffer = kernel32.VirtualAlloc(0, 8, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE)
        if not lpInBuffer:
            raise RuntimeError(f"Failed to allocate memory for input buffer. Error code: {kernel32.GetLastError()}")

        ctypes.memmove(lpInBuffer, struct.pack('I', msr_index), 4)

        lpOutBuffer = kernel32.VirtualAlloc(0, 8, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE)
        if not lpOutBuffer:
            kernel32.VirtualFree(lpInBuffer, 0, 0x8000)
            raise RuntimeError(f"Failed to allocate memory for output buffer. Error code: {kernel32.GetLastError()}")

        dwBytesReturned = wintypes.DWORD(0)
        success = kernel32.DeviceIoControl(
            handle,
            IOCTL_CODE_READ_MSR,
            lpInBuffer,
            4,
            lpOutBuffer,
            8,
            ctypes.byref(dwBytesReturned),
            None
        )

        if not success:
            raise RuntimeError(f"Failed to send IOCTL 0x{IOCTL_CODE_READ_MSR:08X}. Error code: {kernel32.GetLastError()}")

        msr_value = struct.unpack('Q', ctypes.string_at(lpOutBuffer, 8))[0]
        return msr_value

    finally:
        if lpInBuffer:
            kernel32.VirtualFree(lpInBuffer, 0, 0x8000)
        if lpOutBuffer:
            kernel32.VirtualFree(lpOutBuffer, 0, 0x8000)
        kernel32.CloseHandle(handle)

# Function to write MSR
def write_msr(msr_index, msr_value):
    try:
        handle = open_device_handle(DEVICE_NAME, GENERIC_WRITE)

        lpInBuffer = kernel32.VirtualAlloc(0, 12, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE)
        if not lpInBuffer:
            raise RuntimeError(f"Failed to allocate memory for input buffer. Error code: {kernel32.GetLastError()}")

        ctypes.memmove(lpInBuffer, struct.pack('IQ', msr_index, msr_value), 12)

        dwBytesReturned = wintypes.DWORD(0)
        success = kernel32.DeviceIoControl(
            handle,
            IOCTL_CODE_WRITE_MSR,
            lpInBuffer,
            12,
            None,
            0,
            ctypes.byref(dwBytesReturned),
            None
        )

        if not success:
            raise RuntimeError(f"Failed to send IOCTL 0x{IOCTL_CODE_WRITE_MSR:08X}. Error code: {kernel32.GetLastError()}")

    finally:
        if lpInBuffer:
            kernel32.VirtualFree(lpInBuffer, 0, MEM_RESERVE)
        kernel32.CloseHandle(handle)

# Main function to parse arguments and execute operations
def main():
    parser = argparse.ArgumentParser(description="Execute MMIO, MSR read or write, or halt execution")
    parser.add_argument("--mmio", action="store_true", help="Execute MMIO IOCTL")
    parser.add_argument("--halt", action="store_true", help="Execute _halt IOCTL")
    parser.add_argument("--read", action="store_true", help="Read MSRs")
    parser.add_argument("--write", action="store_true", help="Write to MSRs")
    args = parser.parse_args()

    if args.mmio:
        execute_mmio_ioctl()

    if args.halt:
        execute_halt_execution()

    if args.read:
        print("Querying MSRs...")
        for msr_name, msr_index, msr_format in MSR_LIST:
            msr_value = read_msr(msr_index)
            if msr_value is not None:
                print(f"- {msr_name}: {msr_format}".format(msr_value))
        print("Successfully queried MSRs.")

    if args.write:
        msr_index = 0x10  # Example MSR index (IA32_APIC_BASE)
        msr_value = 0xDEADBEEF  # Example value to write
        write_msr(msr_index, msr_value)
        print(f"Successfully wrote value {msr_value:016X} to MSR 0x{msr_index:08X}")

if __name__ == "__main__":
    main()
