#  Quanta Computer Multiple Driver Vulnerabilities

---

ControlCenter.sys/ControlCenter64.sys in ThundeRobot Control Center v2.0.0.10 by Quanta Computer Inc. for multiple OEM's including ThundeRobot exposes functionality that allows low-privileged users to map arbitrary physical memory, read write MSRs and i/o port, read PMC via specially crafted IOCTL requests. This can be exploited for privilege escalation, code execution under high privileges, and information disclosure. These signed drivers can also be used to bypass the Microsoft driver-signing policy to deploy malicious code.  

## version

2.0.0.10

## Vulnerability causes

ControlCenter.sys/ControlCenter64.sys provides the functionality of mapping physical memory, read/write MSR registers and I/O ports, read PMC,  but it does not restrict the privileges of the caller, resulting in low-privileged users being able to call the driver and execute corresponding functions through DeviceIoControl.


~~~c
__int64 __fastcall Possible_DispatchDeviceControl_0(__int64 a1, IRP *a2)
{
  ULONG_PTR *v2; // rdi
  IRP *v4; // rdx
  unsigned int v5; // ebx
  unsigned int v6; // eax
  _IRP *v7; // rcx
  ULONG v8; // er8
  int v9; // edx
  unsigned int v10; // eax
  unsigned __int32 v11; // eax
  CSHORT v12; // ax
  unsigned __int8 v13; // al
  _IRP *v14; // rax
  unsigned int v15; // ebx
  _IRP *v16; // r9
  _IRP *v17; // rcx
  int v18; // edx
  int v19; // ebp
  ULONG *v20; // r9
  ULONG v21; // eax
  int v22; // eax

  v2 = &a2->IoStatus.Information;
  v4 = (IRP *)a2->Tail.Overlay.CurrentStackLocation;
  *v2 = 0i64;
  v5 = -1073741822;
  if ( !LOBYTE(v4->Type) )
  {
    if ( dword_13110 == -1 )
      goto LABEL_69;
    v22 = dword_13110 + 1;
    goto LABEL_68;
  }
  if ( LOBYTE(v4->Type) == 2 )
  {
    if ( dword_13110 == -1 )
      goto LABEL_69;
    v22 = dword_13110 - 1;
LABEL_68:
    dword_13110 = v22;
    goto LABEL_69;
  }
  if ( LOBYTE(v4->Type) != 14 )
    goto LABEL_70;
  v6 = v4->AssociatedIrp.IrpCount;
  if ( v6 > 0x9C4060D4 )
  {
    switch ( v6 )
    {
      case 0x9C406104:
        v10 = sub_1158C(
                a2->AssociatedIrp.MasterIrp,
                v4->Flags,
                a2->AssociatedIrp.MasterIrp,
                v4->MdlAddress,
                (__int64)v2);
        goto LABEL_63;
      case 0x9C406144:
        v19 = (int)v4->MdlAddress;
        if ( v4->Flags != 8 )
          goto LABEL_19;
        v20 = (ULONG *)a2->AssociatedIrp.MasterIrp;
        v21 = HalGetBusDataByOffset(
                PCIConfiguration,
                BYTE1(*v20),
                (32 * (*v20 & 7)) | ((unsigned __int8)*v20 >> 3),
                v20,
                v20[1],
                (ULONG)v4->MdlAddress);
        if ( v21 )
        {
          if ( v19 == 2 || v21 != 2 )
          {
            if ( v19 == v21 )
            {
              *(_DWORD *)v2 = v19;
              goto LABEL_69;
            }
            v5 = -536870908;
          }
          else
          {
            v5 = -536870910;
          }
        }
        else
        {
          v5 = -536870911;
        }
        break;
      case 0x9C40A0C8:
      case 0x9C40A0D8:
      case 0x9C40A0DC:
      case 0x9C40A0E0:
        v17 = a2->AssociatedIrp.MasterIrp;
        v18 = *(_DWORD *)&v17->Type;
        switch ( v6 )
        {
          case 0x9C40A0D8:
            __outbyte(v18, *((_BYTE *)&v17->Size + 2));
            break;
          case 0x9C40A0DC:
            __outword(v18, *(&v17->Size + 1));
            break;
          case 0x9C40A0E0:
            __outdword(v18, *(_DWORD *)(&v17->Size + 1));
            break;
          default:
            goto LABEL_19;
        }
        goto LABEL_69;
      case 0x9C40A108:
        v10 = sub_11654(
                a2->AssociatedIrp.MasterIrp,
                v4->Flags,
                a2->AssociatedIrp.MasterIrp,
                v4->MdlAddress,
                (__int64)v2);
        goto LABEL_63;
      case 0x9C40A148:
        v15 = v4->Flags;
        if ( v15 >= 8 )
        {
          v16 = a2->AssociatedIrp.MasterIrp;
          *(_DWORD *)v2 = 0;
          v5 = v15 - 8 != HalSetBusDataByOffset(
                            PCIConfiguration,
                            (unsigned __int8)BYTE1(*(_DWORD *)&v16->Type),
                            (32 * (*(_DWORD *)&v16->Type & 7)) | ((unsigned __int8)*(_DWORD *)&v16->Type >> 3),
                            &v16->MdlAddress,
                            *(_DWORD *)(&v16->Size + 1),
                            v15 - 8) ? 0xE0000003 : 0;
          goto LABEL_70;
        }
        goto LABEL_19;
      case 0xA2AB208C:
        v5 = 0;
        if ( LODWORD(v4->MdlAddress) >= 4 )
        {
          v14 = a2->AssociatedIrp.MasterIrp;
          v14->Type = 1;
          v14->Size = 0;
          *(_DWORD *)v2 = 4;
          goto LABEL_70;
        }
        v5 = -1073741789;
        break;
      default:
        goto LABEL_70;
    }
    *(_DWORD *)v2 = 0;
    goto LABEL_70;
  }
  switch ( v6 )
  {
    case 0x9C4060D4:
LABEL_15:
      v7 = a2->AssociatedIrp.MasterIrp;
      v8 = v4->Flags;
      v9 = *(_DWORD *)&v7->Type;
      switch ( v6 )
      {
        case 0x9C4060CC:
          v13 = __inbyte(v9);
          LOBYTE(v7->Type) = v13;
          break;
        case 0x9C4060D0:
          v12 = __inword(v9);
          v7->Type = v12;
          break;
        case 0x9C4060D4:
          v11 = __indword(v9);
          *(_DWORD *)&v7->Type = v11;
          break;
        default:
          *(_DWORD *)v2 = 0;
LABEL_19:
          v5 = -1073741811;
          goto LABEL_70;
      }
      *(_DWORD *)v2 = v8;
LABEL_69:
      v5 = 0;
      break;
    case 0x9C402000:
      *(_DWORD *)a2->AssociatedIrp.MasterIrp = 8;
      goto LABEL_25;
    case 0x9C402004:
      *(_DWORD *)a2->AssociatedIrp.MasterIrp = dword_13110;
LABEL_25:
      *v2 = 4i64;
      goto LABEL_69;
    case 0x9C402084:
      v10 = sub_114F0(a2->AssociatedIrp.MasterIrp, v4->Flags, a2->AssociatedIrp.MasterIrp, v4->MdlAddress, (__int64)v2);
      goto LABEL_63;
    case 0x9C402088:
      v10 = sub_11524(a2->AssociatedIrp.MasterIrp, v4->Flags, a2->AssociatedIrp.MasterIrp, v4->MdlAddress, (__int64)v2);
      goto LABEL_63;
    case 0x9C40208C:
      v10 = sub_11558(a2->AssociatedIrp.MasterIrp, v4->Flags, a2->AssociatedIrp.MasterIrp, v4->MdlAddress, (__int64)v2);
LABEL_63:
      v5 = v10;
      break;
    case 0x9C402090:
      __halt();
    case 0x9C4060C4:
    case 0x9C4060CC:
    case 0x9C4060D0:
      goto LABEL_15;
  }
LABEL_70:
  a2->IoStatus.Status = v5;
  IofCompleteRequest(a2, 0);
  return v5;
}
~~~

### Arbitrary Physical Memory Read using MmMapIoSpace 

*  IOCTL  0x9C406104
*  IOCTL  0x9C40A108 

> The MmMapIoSpace routine maps the given physical address range to nonpaged system space â€“ MSDN


~~~c

__int64 __fastcall sub_1158C(PHYSICAL_ADDRESS *a1, int a2, void *a3, unsigned int a4, unsigned int *a5)
{
  unsigned int v9; // eax
  SIZE_T v10; // r12
  PVOID v11; // rax
  char v12; // bp
  __int64 v13; // rcx
  _DWORD *v14; // rdi
  _DWORD *v15; // rsi
  __int64 v16; // rcx
  _WORD *v17; // rdi
  _WORD *v18; // rsi

  if ( a2 != 16 )
    return 3221225485i64;
  v9 = a1[1].HighPart * a1[1].LowPart;
  if ( a4 < v9 )
    return 3221225485i64;
  v10 = v9;
  v11 = MmMapIoSpace(*a1, v9, MmNonCached);
  v12 = 0;
  switch ( a1[1].LowPart )
  {
    case 1u:
      qmemcpy(a3, v11, (unsigned int)a1[1].HighPart);
      break;
    case 2u:
      v16 = (unsigned int)a1[1].HighPart;
      v17 = a3;
      v18 = v11;
      while ( v16 )
      {
        *v17++ = *v18++;
        --v16;
      }
      break;
    case 4u:
      v13 = (unsigned int)a1[1].HighPart;
      v14 = a3;
      v15 = v11;
      while ( v13 )
      {
        *v14++ = *v15++;
        --v13;
      }
      break;
    default:
      v12 = 1;
      break;
  }
  MmUnmapIoSpace(v11, v10);
  if ( v12 )
    return 3221225485i64;
  *a5 = a4;
  return 0i64;
}


__int64 __fastcall sub_11654(PHYSICAL_ADDRESS *a1, unsigned int a2, __int64 a3, __int64 a4, _DWORD *a5)
{
  SIZE_T v7; // rbx
  PHYSICAL_ADDRESS *v8; // rax
  char v9; // bp
  __int64 v10; // rcx
  PHYSICAL_ADDRESS *v11; // rsi
  DWORD *v12; // rdi
  __int64 v13; // rcx
  PHYSICAL_ADDRESS *v14; // rsi
  _WORD *v15; // rdi
  signed __int32 v16[10]; // [rsp+0h] [rbp-28h] BYREF

  if ( a2 < 0x10 )
    return 3221225485i64;
  v7 = a1[1].LowPart * a1[1].HighPart;
  if ( a2 < v7 + 16 )
    return 3221225485i64;
  v8 = (PHYSICAL_ADDRESS *)MmMapIoSpace(*a1, v7, MmNonCached);
  v9 = 0;
  switch ( a1[1].LowPart )
  {
    case 1u:
      qmemcpy(v8, &a1[2], (unsigned int)a1[1].HighPart);
      break;
    case 2u:
      v13 = (unsigned int)a1[1].HighPart;
      v14 = a1 + 2;
      v15 = v8;
      while ( v13 )
      {
        *v15 = v14->LowPart;
        v14 = (PHYSICAL_ADDRESS *)((char *)v14 + 2);
        ++v15;
        --v13;
      }
      break;
    case 4u:
      v10 = (unsigned int)a1[1].HighPart;
      v11 = a1 + 2;
      v12 = (DWORD *)v8;
      while ( v10 )
      {
        *v12 = v11->LowPart;
        v11 = (PHYSICAL_ADDRESS *)((char *)v11 + 4);
        ++v12;
        --v10;
      }
      break;
    default:
      v9 = 1;
      goto LABEL_18;
  }
  _InterlockedOr(v16, 0);
LABEL_18:
  MmUnmapIoSpace(v8, v7);
  if ( v9 )
    return 3221225485i64;
  *a5 = 0;
  return 0i64;
}
~~~

### Read/Write MSRs 

> Generates the Write to Model Specific Register (wrmsr) instruction which writes the contents of registers EDX:EAX into the 64-bit model-specific register (MSR) specified in the ECX register

* __readmsr  IOCTL  0x9C402084
* __writemsr IOCTL  0x9C40A148

~~~c 

__int64 __fastcall sub_114F0(unsigned int *a1, __int64 a2, unsigned __int64 *a3, __int64 a4, _DWORD *a5)
{
  unsigned __int64 v5; // rax

  v5 = __readmsr(*a1);
  *a3 = ((unsigned __int64)HIDWORD(v5) << 32) | (unsigned int)v5;
  *a5 = 8;
  return 0i64;
}

__int64 __fastcall sub_11524(__int64 a1, __int64 a2, __int64 a3, __int64 a4, _DWORD *a5)
{
  __writemsr(*(_DWORD *)a1, *(_QWORD *)(a1 + 4));
  *a5 = 0;
  return 0i64;
}


~~~

### Read PMC

> Generates the Write to Model Specific Register (wrmsr) instruction which writes the contents of registers EDX:EAX into the 64-bit model-specific register (MSR) specified in the ECX register

* IOCTL  0x9C40208C


~~~c 

__int64 __fastcall sub_11558(unsigned int *a1, __int64 a2, unsigned __int64 *a3, __int64 a4, _DWORD *a5)
{
  unsigned __int64 v5; // rax

  v5 = __readpmc(*a1);
  *a3 = ((unsigned __int64)HIDWORD(v5) << 32) | (unsigned int)v5;
  *a5 = 8;
  return 0i64;
}

~~~

### Halt

> Halts the microprocessor until an enabled interrupt, a non-maskable interrupt (NMI), or a reset occurs

* IOCTL  0x9C402090


~~~c 

__int64 __fastcall sub_11558(unsigned int *a1, __int64 a2, unsigned __int64 *a3, __int64 a4, _DWORD *a5)
{
  unsigned __int64 v5; // rax

  v5 = __readpmc(*a1);
  *a3 = ((unsigned __int64)HIDWORD(v5) << 32) | (unsigned int)v5;
  *a5 = 8;
  return 0i64;
}

~~~



### Get/Set BusDataByOffset 

* IOCTL  0x9C406144
* IOCTL  0x9C40A148

> These functions retrieve/set information, starting at the offset, about a slot or address on an I/O bus. â€“ MSDN

~~~c 

case 0x9C406144:
        v19 = (int)v4->MdlAddress;
        if ( v4->Flags != 8 )
          goto LABEL_19;
        v20 = (ULONG *)a2->AssociatedIrp.MasterIrp;
        v21 = HalGetBusDataByOffset(
                PCIConfiguration,
                BYTE1(*v20),
                (32 * (*v20 & 7)) | ((unsigned __int8)*v20 >> 3),
                v20,
                v20[1],
                (ULONG)v4->MdlAddress);

case 0x9C40A148:
        v15 = v4->Flags;
        if ( v15 >= 8 )
        {
          v16 = a2->AssociatedIrp.MasterIrp;
          *(_DWORD *)v2 = 0;
          v5 = v15 - 8 != HalSetBusDataByOffset(
                            PCIConfiguration,
                            (unsigned __int8)BYTE1(*(_DWORD *)&v16->Type),
                            (32 * (*(_DWORD *)&v16->Type & 7)) | ((unsigned __int8)*(_DWORD *)&v16->Type >> 3),
                            &v16->MdlAddress,
                            *(_DWORD *)(&v16->Size + 1),
                            v15 - 8) ? 0xE0000003 : 0;
          goto LABEL_70;
        }
        goto LABEL_19;

~~~

### Arbitrary RW to IO ports

> Generates the out instruction, which sends 1 byte specified by Data out the I/O port specified by Port â€“ MSDN

~~~c 

switch ( v6 )
{
    case 0x9C4060D4:
LABEL_15:
      v7 = a2->AssociatedIrp.MasterIrp;
      v8 = v4->Flags;
      v9 = *(_DWORD *)&v7->Type;
      switch ( v6 )
      {
        case 0x9C4060CC:
          v13 = __inbyte(v9);
          LOBYTE(v7->Type) = v13;
          break;
        case 0x9C4060D0:
          v12 = __inword(v9);
          v7->Type = v12;
          break;
        case 0x9C4060D4:
          v11 = __indword(v9);
          *(_DWORD *)&v7->Type = v11;
          break;
        default:
          *(_DWORD *)v2 = 0;
LABEL_19:
          v5 = -1073741811;
          goto LABEL_70;
      }

case 0x9C40A0C8:
      case 0x9C40A0D8:
      case 0x9C40A0DC:
      case 0x9C40A0E0:
        v17 = a2->AssociatedIrp.MasterIrp;
        v18 = *(_DWORD *)&v17->Type;
        switch ( v6 )
        {
          case 0x9C40A0D8:
            __outbyte(v18, *((_BYTE *)&v17->Size + 2));
            break;
          case 0x9C40A0DC:
            __outword(v18, *(&v17->Size + 1));
            break;
          case 0x9C40A0E0:
            __outdword(v18, *(_DWORD *)(&v17->Size + 1));
            break;
          default:
            goto LABEL_19;
        }
        goto LABEL_69;


~~~

### Proof Of Concept 

![](https://github.com/Souhardya/Exploit-PoCs/blob/main/ThundeRobot_Control_Center/PoC.gif)
