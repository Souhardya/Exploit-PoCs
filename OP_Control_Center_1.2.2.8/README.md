#  Uniwill SmIoDriver.sys Multiple Driver Vulnerabilities

---

SmIoDriver.sys in OverPowered Gaming Control Center v1.2.2.8 by Uniwill Technologies Inc. exposes functionality that allows low-privileged users to map arbitrary physical memory, read and write i/o port via specially crafted IOCTL requests. This can be exploited for privilege escalation, code execution under high privileges, and information disclosure. These signed drivers can also be used to bypass the Microsoft driver-signing policy to deploy malicious code.  

## version

1.2.2.8

## Vulnerability causes

SmIoDriver.sys provides the functionality of mapping physical memory, read/write I/O ports, but it does not restrict the privileges of the caller, resulting in low-privileged users being able to call the driver and execute corresponding functions through DeviceIoControl.


~~~c
__int64 __fastcall sub_140006BF0(__int64 a1, IRP *a2)
{
  _IO_STACK_LOCATION *v2; // rbx
  unsigned int v4; // edi
  unsigned int v5; // edx
  ULONG_PTR v6; // rbp
  unsigned int v7; // eax
  ULONG_PTR *v8; // rbx
  unsigned int v9; // eax
  ULONG_PTR *v10; // r14
  int v11; // eax
  _IRP *v12; // rbx
  unsigned int v13; // edx
  unsigned int v14; // edx
  unsigned int v15; // edx
  unsigned int v16; // edx
  unsigned int v17; // edx
  unsigned int v18; // edx
  char v19; // al
  unsigned int v20; // edx
  unsigned int v21; // edx
  unsigned int v22; // edx
  unsigned int v23; // edx

  v2 = a2->Tail.Overlay.CurrentStackLocation;
  v4 = 0;
  v5 = v2->Parameters.Create.Options;
  v6 = v2->Parameters.Read.Length;
  if ( !v5 || !(_DWORD)v6 )
  {
    v4 = -1073741811;
    goto LABEL_51;
  }
  if ( v2->Parameters.Read.ByteOffset.LowPart == 0x40002000 )
  {
    DbgPrint("------------ Called IOCTL_COMMAND_BUFFERED -------------\n");
    v12 = a2->AssociatedIrp.MasterIrp;
    v13 = BYTE5(v12->MdlAddress);
    if ( v13 > 0x24 )
    {
      v20 = v13 - 37;
      if ( v20 )
      {
        v21 = v20 - 1;
        if ( v21 )
        {
          v22 = v21 - 1;
          if ( v22 )
          {
            v23 = v22 - 1;
            if ( v23 )
            {
              if ( v23 != 1 )
                goto LABEL_51;
              DbgPrint("SMIO_I2C_WRITE_BLOCK");
              v19 = sub_140006370((__int64)v12);
            }
            else
            {
              DbgPrint("SMIO_I2C_READ_BLOCK");
              v19 = sub_1400060A8(v12);
            }
          }
          else
          {
            DbgPrint("SMIO_I2C_WRITE_WORD");
            v19 = sub_140006558(v12);
          }
        }
        else
        {
          DbgPrint("SMIO_I2C_READ_WORD");
          v19 = sub_1400062A4(v12);
        }
      }
      else
      {
        DbgPrint("SMIO_I2C_WRITE_BYTE");
        v19 = sub_1400064A8((__int64)v12);
      }
    }
    else
    {
      if ( v13 != 36 )
      {
        v14 = v13 - 17;
        if ( v14 )
        {
          v15 = v14 - 1;
          if ( v15 )
          {
            v16 = v15 - 1;
            if ( v16 )
            {
              v17 = v16 - 1;
              if ( v17 )
              {
                v18 = v17 - 1;
                if ( v18 )
                {
                  if ( v18 != 1 )
                    goto LABEL_51;
                  DbgPrint("SMIO_PORT_WRITE_DWORD");
                  sub_1400069A4((__int64)v12);
                }
                else
                {
                  DbgPrint("SMIO_PORT_READ_DWORD");
                  sub_1400068CC((__int64)v12);
                }
              }
              else
              {
                DbgPrint("SMIO_PORT_WRITE_WORD");
                sub_1400069E4(v12);
              }
            }
            else
            {
              DbgPrint("SMIO_PORT_READ_WORD");
              sub_140006918((__int64)v12);
            }
          }
          else
          {
            DbgPrint("SMIO_PORT_WRITE_BYTE");
            sub_140006964(v12);
          }
        }
        else
        {
          DbgPrint("SMIO_PORT_READ_BYTE");
          sub_140006880(v12);
        }
LABEL_31:
        a2->IoStatus.Information = v6;
        goto LABEL_51;
      }
      DbgPrint("SMIO_I2C_READ_BYTE");
      v19 = sub_1400061F0((unsigned __int8 *)v12);
    }
    if ( !v19 )
    {
      v4 = -1073741790;
      goto LABEL_51;
    }
    goto LABEL_31;
  }
  if ( v2->Parameters.Read.ByteOffset.LowPart == 0x40002004 )
  {
    v10 = &a2->IoStatus.Information;
    v11 = sub_140006A28(
            (unsigned int *)(unsigned int)a2->AssociatedIrp.MasterIrp,
            v5,
            (void *)(unsigned int)a2->AssociatedIrp.MasterIrp,
            v6,
            (unsigned int *)&a2->IoStatus.Information);
  }
  else
  {
    if ( v2->Parameters.Read.ByteOffset.LowPart == 0x40002008 )
    {
      v8 = &a2->IoStatus.Information;
      v9 = sub_140006AFC(
             (unsigned int *)a2->AssociatedIrp.MasterIrp,
             v5,
             (__int64)a2->AssociatedIrp.MasterIrp,
             (unsigned int)v6,
             &a2->IoStatus.Information);
      goto LABEL_19;
    }
    if ( v2->Parameters.Read.ByteOffset.LowPart != 0x4000600C )
    {
      if ( v2->Parameters.Read.ByteOffset.LowPart != 0x4000A010 )
      {
        if ( v2->Parameters.Read.ByteOffset.LowPart == 0x4000A014 )
        {
          v7 = sub_1400067DC((char *)a2->AssociatedIrp.MasterIrp);
        }
        else
        {
          if ( v2->Parameters.Read.ByteOffset.LowPart != 0x4000A018 )
          {
            v4 = -1073741808;
            DbgPrint("ERROR: unrecognized IOCTL %x\n", v2->Parameters.Read.ByteOffset.LowPart);
            goto LABEL_51;
          }
          v7 = sub_140006744(a2->AssociatedIrp.MasterIrp);
        }
        a2->IoStatus.Information = 0i64;
        v4 = v7;
        goto LABEL_51;
      }
      v8 = &a2->IoStatus.Information;
      v9 = sub_140001188(
             (unsigned int *)(unsigned int)a2->AssociatedIrp.MasterIrp,
             v5,
             (unsigned int)a2->AssociatedIrp.MasterIrp,
             (unsigned int)v6,
             &a2->IoStatus.Information);
LABEL_19:
      *v8 = 0i64;
      v4 = v9;
      goto LABEL_51;
    }
    v10 = &a2->IoStatus.Information;
    v11 = sub_140001154(
            (_DWORD *)(unsigned int)a2->AssociatedIrp.MasterIrp,
            v5,
            (void *)(unsigned int)a2->AssociatedIrp.MasterIrp,
            v6,
            (ULONG *)&a2->IoStatus.Information);
  }
  v4 = v11;
  if ( v11 < 0 )
    *v10 = 0i64;
  else
    *v10 = v2->Parameters.Read.Length;
LABEL_51:
  a2->IoStatus.Status = v4;
  IofCompleteRequest(a2, 0);
  return v4;
}
~~~

### MmMapIoSpace 

*  IOCTL  0x40002004
*  IOCTL  0x40002008 

> The MmMapIoSpace routine maps the given physical address range to nonpaged system space – MSDN


~~~c

__int64 __fastcall sub_140006A28(unsigned int *a1, int a2, void *a3, unsigned int a4, unsigned int *a5)
{
  unsigned int v9; // ecx
  SIZE_T v10; // r14
  PVOID v11; // rax
  char v12; // bp
  __int64 v13; // rcx
  _DWORD *v14; // rdi
  _DWORD *v15; // rsi
  __int64 v16; // rcx
  _WORD *v17; // rdi
  _WORD *v18; // rsi

  if ( a2 != 12 )
    return 3221225485i64;
  v9 = a1[2] * a1[1];
  if ( a4 < v9 )
    return 3221225485i64;
  v10 = v9;
  v11 = MmMapIoSpace((PHYSICAL_ADDRESS)*a1, v9, MmNonCached);
  v12 = 0;
  switch ( a1[1] )
  {
    case 1u:
      qmemcpy(a3, v11, a1[2]);
      break;
    case 2u:
      v16 = a1[2];
      v17 = a3;
      v18 = v11;
      while ( v16 )
      {
        *v17++ = *v18++;
        --v16;
      }
      break;
    case 4u:
      v13 = a1[2];
      v14 = a3;
      v15 = v11;
      while ( v13 )
      {
        *v14++ = *v15++;
        --v13;
      }
      break;
    default:
      v12 = 1;
      break;
  }
  MmUnmapIoSpace(v11, v10);
  if ( v12 )
    return 3221225485i64;
  *a5 = a4;
  return 0i64;
}


__int64 __fastcall sub_140006AFC(unsigned int *a1, unsigned int a2, __int64 a3, __int64 a4, _DWORD *a5)
{
  SIZE_T v7; // rbx
  unsigned int *v8; // rax
  char v9; // bp
  __int64 v10; // rcx
  _DWORD *v11; // rdi
  unsigned int *v12; // rsi
  __int64 v13; // rcx
  _WORD *v14; // rdi
  unsigned int *v15; // rsi
  signed __int32 v16[8]; // [rsp+0h] [rbp-38h] BYREF
  PHYSICAL_ADDRESS PhysicalAddress; // [rsp+20h] [rbp-18h]

  if ( a2 < 0xC )
    return 3221225485i64;
  v7 = a1[1] * a1[2];
  if ( a2 < v7 + 12 )
    return 3221225485i64;
  PhysicalAddress.QuadPart = *a1;
  v8 = (unsigned int *)MmMapIoSpace(PhysicalAddress, (unsigned int)v7, MmNonCached);
  v9 = 0;
  switch ( a1[1] )
  {
    case 1u:
      qmemcpy(v8, a1 + 3, a1[2]);
      break;
    case 2u:
      v13 = a1[2];
      v14 = v8;
      v15 = a1 + 3;
      while ( v13 )
      {
        *v14 = *(_WORD *)v15;
        v15 = (unsigned int *)((char *)v15 + 2);
        ++v14;
        --v13;
      }
      break;
    case 4u:
      v10 = a1[2];
      v11 = v8;
      v12 = a1 + 3;
      while ( v10 )
      {
        *v11++ = *v12++;
        --v10;
      }
      break;
    default:
      v9 = 1;
      goto LABEL_18;
  }
  _InterlockedOr(v16, 0);
LABEL_18:
  MmUnmapIoSpace(v8, v7);
  if ( v9 )
    return 3221225485i64;
  *a5 = 0;
  return 0i64;
}
~~~

### Get/Set BusDataByOffset 

* IOCTL  0x4000600C 

> These functions retrieve/set information, starting at the offset, about a slot or address on an I/O bus. – MSDN

~~~c 

__int64 __fastcall sub_140001000(__int16 a1, ULONG a2, void *a3, ULONG a4)
{
  unsigned int v8; // er15
  KIRQL v9; // bp
  ULONG v10; // eax

  v8 = 0;
  v9 = KeAcquireSpinLockRaiseToDpc(&SpinLock);
  v10 = HalGetBusDataByOffset(PCIConfiguration, HIBYTE(a1), (32 * (a1 & 7)) | ((unsigned __int8)a1 >> 3), a3, a2, a4);
  if ( !v10 )
    v8 = -536870911;
  if ( a4 != v10 )
    v8 = -536870908;
  KeReleaseSpinLock(&SpinLock, v9);
  return v8;
}

__int64 __fastcall sub_1400010B0(__int16 a1, ULONG a2, void *a3, ULONG a4)
{
  unsigned int v8; // er15
  KIRQL v9; // bp

  v8 = 0;
  v9 = KeAcquireSpinLockRaiseToDpc(&SpinLock);
  if ( HalSetBusDataByOffset(PCIConfiguration, HIBYTE(a1), (32 * (a1 & 7)) | ((unsigned __int8)a1 >> 3), a3, a2, a4) != a4 )
    v8 = -536870909;
  KeReleaseSpinLock(&SpinLock, v9);
  return v8;
}

~~~

### Read/Write 1/2/4 bytes

> Generates the out instruction, which sends 1 byte specified by Data out the I/O port specified by Port – MSDN

~~~c 

char __fastcall sub_140006370(__int64 a1)
{
  unsigned int v2; // ebx
  unsigned __int8 i; // bl

  DbgPrint("Enter I2CWriteBlock Function\n");
  sub_140006024();
  sub_140006758();
  if ( (unsigned __int8)sub_1400066F0() )
  {
    v2 = (*(_DWORD *)(a1 + 1) << 24) + 5505278;
    DbgPrint("Slave Address Register = 0x%x\n", *(_BYTE *)a1 & 0xFE);
    DbgPrint("SMBus Command = 0x%x\n", v2);
    sub_140006000();
    __outbyte(word_140003014 + 4, *(_BYTE *)a1 & 0xFE);
    __outbyte(word_140003014 + 7, *(_BYTE *)(*(unsigned int *)(a1 + 1) + a1 + 270));
    DbgPrint("SMBus Writeing block Data = 0x%x\n", *(unsigned __int8 *)(*(unsigned int *)(a1 + 1) + a1 + 270));
    __outword(word_140003014 + 5, *(_WORD *)(a1 + 530));
    DbgPrint("Block Write Length = %d\n", *(unsigned int *)(a1 + 530));
    __outdword(word_140003014, v2);
    for ( i = 1;
          i < *(int *)(a1 + 530);
          DbgPrint(
            "SMBus Writeing block Data = 0x%x\n",
            *(unsigned __int8 *)((unsigned int)i++ + *(_DWORD *)(a1 + 1) + a1 + 270)) )
    {
      if ( !(unsigned __int8)sub_14000660C() )
        break;
      __outbyte(word_140003014 + 7, *(_BYTE *)((unsigned int)i + *(_DWORD *)(a1 + 1) + a1 + 270));
    }
  }
  return 0;
}

ULONG __fastcall sub_140006918(__int64 a1)
{
  unsigned __int16 v2; // ax
  __int64 v3; // rdx
  unsigned int v4; // ebx

  DbgPrint("Enter IOReadWord Function\n");
  v2 = __inword(*(_DWORD *)(a1 + 1));
  v3 = *(unsigned int *)(a1 + 1);
  v4 = v2;
  *(_DWORD *)(a1 + 5) = v2;
  DbgPrint("Port = 0x%x\n", v3);
  return DbgPrint("Read Data = 0x%x\n", v4);
}

~~~


