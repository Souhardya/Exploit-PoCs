#  SmIoDriver.sys in OverPowered Control Center v1.2.2.8 physical memory read

---

SmIoDriver.sys in OverPowered Control Center v1.2.2.8 exposes functionality that allows low-privileged users to map arbitrary physical memory, read and write i/o port via specially crafted IOCTL requests. This can be exploited for privilege escalation, code execution under high privileges, and information disclosure. These signed drivers can also be used to bypass the Microsoft driver-signing policy to deploy malicious code.  

## version

1.2.2.8

## Vulnerability causes

SmIoDriver.sys provides the functionality of mapping physical memory, read/write I/O ports, but it does not restrict the privileges of the caller, resulting in low-privileged users being able to call the driver and execute corresponding functions through DeviceIoControl.


~~~c
__int64 __fastcall sub_140006BF0(__int64 a1, IRP *a2)
{
  _IO_STACK_LOCATION *v2; // rbx
  unsigned int v4; // edi
  unsigned int v5; // edx
  ULONG_PTR v6; // rbp
  unsigned int v7; // eax
  ULONG_PTR *v8; // rbx
  unsigned int v9; // eax
  ULONG_PTR *v10; // r14
  int v11; // eax
  _IRP *v12; // rbx
  unsigned int v13; // edx
  unsigned int v14; // edx
  unsigned int v15; // edx
  unsigned int v16; // edx
  unsigned int v17; // edx
  unsigned int v18; // edx
  char v19; // al
  unsigned int v20; // edx
  unsigned int v21; // edx
  unsigned int v22; // edx
  unsigned int v23; // edx

  v2 = a2->Tail.Overlay.CurrentStackLocation;
  v4 = 0;
  v5 = v2->Parameters.Create.Options;
  v6 = v2->Parameters.Read.Length;
  if ( !v5 || !(_DWORD)v6 )
  {
    v4 = -1073741811;
    goto LABEL_51;
  }
  if ( v2->Parameters.Read.ByteOffset.LowPart == 0x40002000 )
  {
    DbgPrint("------------ Called IOCTL_COMMAND_BUFFERED -------------\n");
    v12 = a2->AssociatedIrp.MasterIrp;
    v13 = BYTE5(v12->MdlAddress);
    if ( v13 > 0x24 )
    {
      v20 = v13 - 37;
      if ( v20 )
      {
        v21 = v20 - 1;
        if ( v21 )
        {
          v22 = v21 - 1;
          if ( v22 )
          {
            v23 = v22 - 1;
            if ( v23 )
            {
              if ( v23 != 1 )
                goto LABEL_51;
              DbgPrint("SMIO_I2C_WRITE_BLOCK");
              v19 = sub_140006370((__int64)v12);
            }
            else
            {
              DbgPrint("SMIO_I2C_READ_BLOCK");
              v19 = sub_1400060A8(v12);
            }
          }
          else
          {
            DbgPrint("SMIO_I2C_WRITE_WORD");
            v19 = sub_140006558(v12);
          }
        }
        else
        {
          DbgPrint("SMIO_I2C_READ_WORD");
          v19 = sub_1400062A4(v12);
        }
      }
      else
      {
        DbgPrint("SMIO_I2C_WRITE_BYTE");
        v19 = sub_1400064A8((__int64)v12);
      }
    }
    else
    {
      if ( v13 != 36 )
      {
        v14 = v13 - 17;
        if ( v14 )
        {
          v15 = v14 - 1;
          if ( v15 )
          {
            v16 = v15 - 1;
            if ( v16 )
            {
              v17 = v16 - 1;
              if ( v17 )
              {
                v18 = v17 - 1;
                if ( v18 )
                {
                  if ( v18 != 1 )
                    goto LABEL_51;
                  DbgPrint("SMIO_PORT_WRITE_DWORD");
                  sub_1400069A4((__int64)v12);
                }
                else
                {
                  DbgPrint("SMIO_PORT_READ_DWORD");
                  sub_1400068CC((__int64)v12);
                }
              }
              else
              {
                DbgPrint("SMIO_PORT_WRITE_WORD");
                sub_1400069E4(v12);
              }
            }
            else
            {
              DbgPrint("SMIO_PORT_READ_WORD");
              sub_140006918((__int64)v12);
            }
          }
          else
          {
            DbgPrint("SMIO_PORT_WRITE_BYTE");
            sub_140006964(v12);
          }
        }
        else
        {
          DbgPrint("SMIO_PORT_READ_BYTE");
          sub_140006880(v12);
        }
LABEL_31:
        a2->IoStatus.Information = v6;
        goto LABEL_51;
      }
      DbgPrint("SMIO_I2C_READ_BYTE");
      v19 = sub_1400061F0((unsigned __int8 *)v12);
    }
    if ( !v19 )
    {
      v4 = -1073741790;
      goto LABEL_51;
    }
    goto LABEL_31;
  }
  if ( v2->Parameters.Read.ByteOffset.LowPart == 0x40002004 )
  {
    v10 = &a2->IoStatus.Information;
    v11 = sub_140006A28(
            (unsigned int *)(unsigned int)a2->AssociatedIrp.MasterIrp,
            v5,
            (void *)(unsigned int)a2->AssociatedIrp.MasterIrp,
            v6,
            (unsigned int *)&a2->IoStatus.Information);
  }
  else
  {
    if ( v2->Parameters.Read.ByteOffset.LowPart == 0x40002008 )
    {
      v8 = &a2->IoStatus.Information;
      v9 = sub_140006AFC(
             (unsigned int *)a2->AssociatedIrp.MasterIrp,
             v5,
             (__int64)a2->AssociatedIrp.MasterIrp,
             (unsigned int)v6,
             &a2->IoStatus.Information);
      goto LABEL_19;
    }
    if ( v2->Parameters.Read.ByteOffset.LowPart != 0x4000600C )
    {
      if ( v2->Parameters.Read.ByteOffset.LowPart != 0x4000A010 )
      {
        if ( v2->Parameters.Read.ByteOffset.LowPart == 0x4000A014 )
        {
          v7 = sub_1400067DC((char *)a2->AssociatedIrp.MasterIrp);
        }
        else
        {
          if ( v2->Parameters.Read.ByteOffset.LowPart != 0x4000A018 )
          {
            v4 = -1073741808;
            DbgPrint("ERROR: unrecognized IOCTL %x\n", v2->Parameters.Read.ByteOffset.LowPart);
            goto LABEL_51;
          }
          v7 = sub_140006744(a2->AssociatedIrp.MasterIrp);
        }
        a2->IoStatus.Information = 0i64;
        v4 = v7;
        goto LABEL_51;
      }
      v8 = &a2->IoStatus.Information;
      v9 = sub_140001188(
             (unsigned int *)(unsigned int)a2->AssociatedIrp.MasterIrp,
             v5,
             (unsigned int)a2->AssociatedIrp.MasterIrp,
             (unsigned int)v6,
             &a2->IoStatus.Information);
LABEL_19:
      *v8 = 0i64;
      v4 = v9;
      goto LABEL_51;
    }
    v10 = &a2->IoStatus.Information;
    v11 = sub_140001154(
            (_DWORD *)(unsigned int)a2->AssociatedIrp.MasterIrp,
            v5,
            (void *)(unsigned int)a2->AssociatedIrp.MasterIrp,
            v6,
            (ULONG *)&a2->IoStatus.Information);
  }
  v4 = v11;
  if ( v11 < 0 )
    *v10 = 0i64;
  else
    *v10 = v2->Parameters.Read.Length;
LABEL_51:
  a2->IoStatus.Status = v4;
  IofCompleteRequest(a2, 0);
  return v4;
}
~~~

### IOCTL  0x40002004,0x40002008


> The MmMapIoSpace routine maps the given physical address range to nonpaged system space â€“ MSDN


This IOCTL code triggers memory map operation. 

~~~c

__int64 __fastcall sub_140006A28(unsigned int *a1, int a2, void *a3, unsigned int a4, unsigned int *a5)
{
  unsigned int v9; // ecx
  SIZE_T v10; // r14
  PVOID v11; // rax
  char v12; // bp
  __int64 v13; // rcx
  _DWORD *v14; // rdi
  _DWORD *v15; // rsi
  __int64 v16; // rcx
  _WORD *v17; // rdi
  _WORD *v18; // rsi

  if ( a2 != 12 )
    return 3221225485i64;
  v9 = a1[2] * a1[1];
  if ( a4 < v9 )
    return 3221225485i64;
  v10 = v9;
  v11 = MmMapIoSpace((PHYSICAL_ADDRESS)*a1, v9, MmNonCached);
  v12 = 0;
  switch ( a1[1] )
  {
    case 1u:
      qmemcpy(a3, v11, a1[2]);
      break;
    case 2u:
      v16 = a1[2];
      v17 = a3;
      v18 = v11;
      while ( v16 )
      {
        *v17++ = *v18++;
        --v16;
      }
      break;
    case 4u:
      v13 = a1[2];
      v14 = a3;
      v15 = v11;
      while ( v13 )
      {
        *v14++ = *v15++;
        --v13;
      }
      break;
    default:
      v12 = 1;
      break;
  }
  MmUnmapIoSpace(v11, v10);
  if ( v12 )
    return 3221225485i64;
  *a5 = a4;
  return 0i64;
}


__int64 __fastcall sub_140006AFC(unsigned int *a1, unsigned int a2, __int64 a3, __int64 a4, _DWORD *a5)
{
  SIZE_T v7; // rbx
  unsigned int *v8; // rax
  char v9; // bp
  __int64 v10; // rcx
  _DWORD *v11; // rdi
  unsigned int *v12; // rsi
  __int64 v13; // rcx
  _WORD *v14; // rdi
  unsigned int *v15; // rsi
  signed __int32 v16[8]; // [rsp+0h] [rbp-38h] BYREF
  PHYSICAL_ADDRESS PhysicalAddress; // [rsp+20h] [rbp-18h]

  if ( a2 < 0xC )
    return 3221225485i64;
  v7 = a1[1] * a1[2];
  if ( a2 < v7 + 12 )
    return 3221225485i64;
  PhysicalAddress.QuadPart = *a1;
  v8 = (unsigned int *)MmMapIoSpace(PhysicalAddress, (unsigned int)v7, MmNonCached);
  v9 = 0;
  switch ( a1[1] )
  {
    case 1u:
      qmemcpy(v8, a1 + 3, a1[2]);
      break;
    case 2u:
      v13 = a1[2];
      v14 = v8;
      v15 = a1 + 3;
      while ( v13 )
      {
        *v14 = *(_WORD *)v15;
        v15 = (unsigned int *)((char *)v15 + 2);
        ++v14;
        --v13;
      }
      break;
    case 4u:
      v10 = a1[2];
      v11 = v8;
      v12 = a1 + 3;
      while ( v10 )
      {
        *v11++ = *v12++;
        --v10;
      }
      break;
    default:
      v9 = 1;
      goto LABEL_18;
  }
  _InterlockedOr(v16, 0);
LABEL_18:
  MmUnmapIoSpace(v8, v7);
  if ( v9 )
    return 3221225485i64;
  *a5 = 0;
  return 0i64;
}
~~~


